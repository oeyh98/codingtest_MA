> 해당 프로젝트는 MementoAI 인턴 코딩테스트 제출용으로 작성되었습니다

## 지원자

---
- 양진혁
- 98.12.25
- 010-3298-6409

## 코딩테스트 안내 

---
- 제출 기한: 2024.10.01 까지
- 제출 방식: 
  - 첨부파일 문제 두개 중 하나의 문제를 선택
  - GitHub에 문제를 푼 후 링크를 메일로 회신

## 문제 내용

---
### 1번 문제) 제일 작은 수 제거하기

문제 설명
정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을
완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에-1을 채워 리턴하세요.
예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.

제한 조건
- arr은 길이 1 이상인 배열입니다.
- 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다.

입출력 예

입력 > [4, 3, 2, 1], 출력 > [4, 3, 2]
입력 > [10] 출력 > [-1]

### 2번 문제) 문자열 내림차순으로 배치하기

문제 설명
문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수,
solution을 완성해주세요.
s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.

제한 사항 
- str은 길이 1 이상인 문자열입니다.

입력 > "Zbcdefg", 출력 > "gfedcbZ"

## 제출 답안

---
- 선택 문제 : 1번 문제) 제일 작은 수 제거하기
- 풀이 언어 : Python
- 풀이 환경 : PyCharm

### 문제 풀이
```
def solution(arr):
    min_value = min(arr)
    arr = [x for x in arr if x != min_value] 

    return arr if arr else [-1]
```

- 아이디어: 배열에서 유일한 최솟값을 찾아 이를 제외한 새로운 배열 생성.
  - 유일 : 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j]


- 시간 복잡도: O(n)
  - 최솟값 찾기 (min(arr)) : O(n)
    - 선형 탐색(Linear Search)
  - 리스트 생성 ([x for x in arr if x != min_value]): O(n)
    - 새로운 리스트를 생성을 위해 배열을 다시 순회
    - 왜 remove가 아닌 리스트 컴프리헨션?
      - remove나 리스트 컴프리헨션 모두 시간복잡도는 O(n)
        - remove는 최솟값을 제거후, 이후 리스트의 요소 이동이 이루어짐
        - 리스트 컴프리헨션은 조건의 맞는 요소로 이루어진 새로운 리스트를 생성
      - 결론 : 요소를 찾아 제거하고, 이후 데이터를 이동시키는 remove보다는, 메모리의 할당이 필요하나 요소이동이 없는 리스트 컴프리헨션이 상대적으로 단순하다고 생각하여 선택하였습니다
      

- 자료구조 & 알고리즘: 선형 탐색(Linear Search), 파이썬 리스트 컴프리헨션(List Comprehension)